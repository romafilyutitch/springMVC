package com.epam.esm.dao;

import com.epam.esm.model.Entity;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Component;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Optional;
import java.util.StringJoiner;


/**
 * Dao layer abstract dao class. If it is need to make dao for some
 * entity. You may extend this class to get basic CRUD operations.
 * Uses MySQL database to to save and manipulate entities.
 *
 * @param <T> entity which dao operates
 */
@Component
public abstract class AbstractDao<T extends Entity> implements Dao<T> {
    @Autowired
    protected JdbcTemplate template;
    private final RowMapper<T> rowMapper;

    private static final String FIND_ALL_SQL_TEMPLATE = "select id, %s from %s limit ?, 5";
    private static final String FIND_BY_ID_SQL_TEMPLATE = "select id, %s from %s where id = ?";
    private static final String SAVE_SQL_TEMPLATE = "insert into %s (%s) values (%s)";
    private static final String UPDATE_SQL_TEMPLATE = "update %s set %s where id = ?";
    private static final String DELETE_SQL_TEMPLATE = "delete from %s where id = ?";
    private static final String COUNT_SQL_TEMPLATE = "select count(*) from %s";
    private static final String COMMA_DELIMITER = ",";
    private static final String QUESTION_MARK = "?";
    private static final String EQUALS_MARK = "=";
    public static final int ROWS_PER_PAGE = 5;

    private final String findAllSql;
    private final String findByIdSql;
    private final String saveSql;
    private final String updateSql;
    private final String deleteSql;
    private final String countSql;

    public AbstractDao(String tableName, List<String> columns, RowMapper<T> rowMapper) {
        this.rowMapper = rowMapper;
        findAllSql = String.format(FIND_ALL_SQL_TEMPLATE, String.join(COMMA_DELIMITER, columns), tableName);
        findByIdSql = String.format(FIND_BY_ID_SQL_TEMPLATE, String.join(COMMA_DELIMITER, columns), tableName);
        StringJoiner saveJoiner = new StringJoiner(COMMA_DELIMITER);
        columns.forEach(column -> saveJoiner.add(QUESTION_MARK));
        saveSql = String.format(SAVE_SQL_TEMPLATE, tableName, String.join(COMMA_DELIMITER, columns), saveJoiner);
        StringJoiner updateJoiner = new StringJoiner(COMMA_DELIMITER);
        columns.forEach(column -> updateJoiner.add(column + EQUALS_MARK + QUESTION_MARK));
        updateSql = String.format(UPDATE_SQL_TEMPLATE, tableName, updateJoiner);
        deleteSql = String.format(DELETE_SQL_TEMPLATE, tableName);
        countSql = String.format(COUNT_SQL_TEMPLATE, tableName);
    }

    /**
     * Performs select database request to find all entities
     *
     * @return list of all entities from database table
     */
    @Override
    public List<T> findPage(long page) {
        return template.query(findAllSql, rowMapper, (ROWS_PER_PAGE * page) - ROWS_PER_PAGE);
    }

    /**
     * Performs select database request to find entity with passed id.
     * May return empty optional if entity was not found
     *
     * @param id id of entity that need to be found
     * @return Optional that contains entity if entity was found or
     * empty optional otherwise
     */
    @Override
    public Optional<T> findById(Long id) {
        List<T> query = template.query(findByIdSql, rowMapper, id);
        return query.isEmpty() ? Optional.empty() : Optional.of(query.get(0));
    }

    /**
     * Saves passed entity and returns entity with assigned id generated by database
     *
     * @param entity entity that need to be saved.
     * @return saved entity with assigned id generated by database
     */
    @Override
    public T save(T entity) {
        GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        template.update(statementCreator -> {
            PreparedStatement saveStatement = statementCreator.prepareStatement(saveSql, Statement.RETURN_GENERATED_KEYS);
            setSaveValues(saveStatement, entity);
            return saveStatement;
        }, keyHolder);
        long id = keyHolder.getKey().longValue();
        return findById(id).orElseThrow(DaoException::new);
    }

    /**
     * Performs update entity operation. All entity fields will be updated.
     *
     * @param entity entity that need to be updated
     * @return updated entity
     */
    @Override
    public T update(T entity) {
        template.update(updateSql, ps -> setUpdateValues(ps, entity));
        return entity;
    }

    /**
     * Performs delete database request to delete entity that has passed id
     *
     * @param id id of entity that need to be deleted
     */
    @Override
    public void delete(Long id) {
        template.update(deleteSql, id);
    }

    @Override
    public long getTotalPages() {
        Long rows = template.queryForObject(countSql, (rs, rowNum) -> rs.getLong("count(*)"));
        long pages =  (rows / ROWS_PER_PAGE);
        return rows % ROWS_PER_PAGE == 0 ? pages : ++pages;
    }

    @Override
    public long getTotalElements() {
        return template.queryForObject(countSql, (rs, rowNum) -> rs.getLong("count(*)"));
    }

    /**
     * Method need to be overridden by subclasses to set entity fields values to PreparedStatement
     * to right save fields values. Template method pattern variation
     *
     * @param saveStatement PreparedStatement that need to be set entity values for save
     * @param entity        entity that need to be saved
     * @throws SQLException if exception with database occurs
     */
    protected abstract void setSaveValues(PreparedStatement saveStatement, T entity) throws SQLException;

    /**
     * Methods need to be overridden by subclasses to set entity fields values to PreparedStatement
     * to right update fields values. Template method pattern variation
     *
     * @param updateStatement Prepared statement that need to be set entity values for update
     * @param entity          entity that need to be updated
     * @throws SQLException if exception with database occurs
     */
    protected abstract void setUpdateValues(PreparedStatement updateStatement, T entity) throws SQLException;
}
